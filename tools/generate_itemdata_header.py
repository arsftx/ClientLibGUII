#!/usr/bin/env python3
"""
Item Data Header Generator for Pet Filter - v2

Converts item.json to a C++ header file (ItemDataGenerated.h)
This header contains all item data in a static array format.
Includes CodeName128 for detailed logging.

Usage:
    python generate_itemdata_header.py

Output:
    ItemDataGenerated.h in the same directory as this script
"""

import json
import os

# Paths
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
JSON_PATH = os.path.join(SCRIPT_DIR, "..", "item.json")
OUTPUT_PATH = os.path.join(SCRIPT_DIR, "..", "source", "libs", "ClientLib", "src", "ItemDataGenerated.h")

def calculate_degree(req_level):
    """Calculate degree from required level (1-15)"""
    if req_level <= 0:
        return 0
    return min(15, (req_level // 10) + 1)

def truncate_name(name, max_len=63):
    """Truncate name to max_len characters"""
    if len(name) > max_len:
        return name[:max_len]
    return name

def main():
    print(f"Loading {JSON_PATH}...")
    
    with open(JSON_PATH, 'r', encoding='utf-8') as f:
        items = json.load(f)
    
    print(f"Loaded {len(items)} items")
    
    # Filter and process items
    entries = []
    for item in items:
        ref_obj_id = item.get('ID', 0)
        if ref_obj_id == 0:
            continue
            
        type_id1 = item.get('TypeID1', 0)
        type_id2 = item.get('TypeID2', 0)
        type_id3 = item.get('TypeID3', 0)
        type_id4 = item.get('TypeID4', 0)
        country = item.get('Country', 0)
        req_level = item.get('ReqLevel1', 0)
        rarity = item.get('Rarity', 0)
        code_name = item.get('CodeName128', '')
        
        # Get Item sub-object data
        item_data = item.get('Item', {})
        if item_data is None:
            item_data = {}
        
        item_class = item_data.get('ItemClass', 0)
        req_gender = item_data.get('ReqGender', 2)  # 2 = both
        
        degree = calculate_degree(req_level)
        
        entries.append({
            'refObjID': ref_obj_id,
            'typeID1': type_id1,
            'typeID2': type_id2,
            'typeID3': type_id3,
            'typeID4': type_id4,
            'degree': degree,
            'gender': req_gender,
            'country': country,
            'itemClass': item_class,
            'rarity': rarity,
            'codeName': truncate_name(code_name)
        })
    
    # Sort by refObjID for binary search potential
    entries.sort(key=lambda x: x['refObjID'])
    
    print(f"Processing {len(entries)} valid items...")
    
    # Generate header file
    header_content = '''/**
 * @file ItemDataGenerated.h
 * @brief Auto-generated item data for Pet Filter
 * 
 * DO NOT EDIT MANUALLY!
 * Generated by: tools/generate_itemdata_header.py
 * Source: item.json
 */

#pragma once
#include <Windows.h>

// Maximum CodeName length
#define CODENAME_MAX_LEN 64

// Item data entry structure
struct ItemDataEntry {
    DWORD refObjID;                 // Reference Object ID (primary key)
    BYTE typeID1;                   // Main category (3 = ITEM)
    BYTE typeID2;                   // Sub category (1=weapon, 2=armor, 3=etc)
    BYTE typeID3;                   // Item type (sword, blade, heavy, light, etc)
    BYTE typeID4;                   // Additional type info
    BYTE degree;                    // Item degree (1-15, calculated from ReqLevel)
    BYTE gender;                    // Required gender (0=male, 1=female, 2=both)
    BYTE country;                   // 0=Chinese, 1=European, 3=Common
    BYTE itemClass;                 // Item class/plus value
    BYTE rarity;                    // Item rarity
    char codeName[CODENAME_MAX_LEN]; // CodeName128 for logging
};

// TypeID1 constants (main category)
namespace ItemCategory {
    const BYTE CHARACTER = 1;
    const BYTE BIONIC = 2;
    const BYTE ITEM = 3;
}

// TypeID2 constants for ITEM (sub-category)
namespace ItemType2 {
    const BYTE WEAPON = 1;
    const BYTE ARMOR = 2;      // Protector, Shield
    const BYTE ACCESSORY = 3;  // Also ETC items
}

// TypeID3 constants for ARMOR (armor type)
namespace ArmorType {
    const BYTE HEAVY = 1;
    const BYTE LIGHT = 2;
    const BYTE CLOTHES = 3;
    const BYTE SHIELD = 4;
}

// TypeID3 constants for ETC items
namespace EtcType {
    const BYTE POTION = 1;
    const BYTE CURE = 2;
    const BYTE SCROLL = 3;
    const BYTE AMMO = 4;
    const BYTE GOLD = 5;
    const BYTE FIREWORK = 6;
    const BYTE CAMPFIRE = 7;
    const BYTE ALCHEMY_STONE = 8;
    const BYTE ALCHEMY_ELIXIR = 9;
    const BYTE ALCHEMY_TABLET = 10;
    const BYTE ALCHEMY_ELEMENT = 11;
}

// TypeID4 constants for weapons
namespace WeaponType {
    const BYTE CH_SWORD = 2;
    const BYTE CH_BLADE = 3;
    const BYTE CH_SPEAR = 4;
    const BYTE CH_GLAIVE = 5;
    const BYTE CH_BOW = 6;
    const BYTE CH_SHIELD = 7;
    const BYTE EU_SWORD = 2;
    const BYTE EU_TSWORD = 3;
    const BYTE EU_AXE = 4;
    const BYTE EU_CROSSBOW = 5;
    const BYTE EU_DAGGER = 6;
    const BYTE EU_STAFF = 7;
    const BYTE EU_ROD = 8;
    const BYTE EU_HARP = 9;
    const BYTE EU_CLERIC = 10;
}

// Gender constants
namespace Gender {
    const BYTE MALE = 0;
    const BYTE FEMALE = 1;
    const BYTE BOTH = 2;
}

// Country constants
namespace Country {
    const BYTE CHINESE = 0;
    const BYTE EUROPEAN = 1;
    const BYTE COMMON = 3;
}

'''

    # Add the data array
    header_content += f"// Total items: {len(entries)}\n"
    header_content += "static const ItemDataEntry g_ItemDataTable[] = {\n"
    
    for i, entry in enumerate(entries):
        # Escape codeName for C string
        code_name_escaped = entry['codeName'].replace('\\', '\\\\').replace('"', '\\"')
        
        header_content += f'    {{{entry["refObjID"]}, {entry["typeID1"]}, {entry["typeID2"]}, {entry["typeID3"]}, {entry["typeID4"]}, {entry["degree"]}, {entry["gender"]}, {entry["country"]}, {entry["itemClass"]}, {entry["rarity"]}, "{code_name_escaped}"}},\n'
    
    header_content += "};\n\n"
    header_content += f"static const size_t g_ItemDataCount = {len(entries)};\n"
    
    # Write output
    os.makedirs(os.path.dirname(OUTPUT_PATH), exist_ok=True)
    with open(OUTPUT_PATH, 'w', encoding='utf-8') as f:
        f.write(header_content)
    
    print(f"Generated {OUTPUT_PATH}")
    print(f"Total entries: {len(entries)}")
    
    # Stats
    weapons = sum(1 for e in entries if e['typeID1'] == 3 and e['typeID2'] == 1)
    armor = sum(1 for e in entries if e['typeID1'] == 3 and e['typeID2'] == 2)
    etc = sum(1 for e in entries if e['typeID1'] == 3 and e['typeID2'] == 3)
    print(f"Weapons: {weapons}, Armor: {armor}, ETC: {etc}")

if __name__ == '__main__':
    main()
